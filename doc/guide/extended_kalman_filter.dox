/*! \file extended_kalman_filter.dox
    \brief Extended Kalman Filter.
*/

/*!
\page extended_kalman_filter Extended Kalman Filter

The extended Kalman filter (EKF) is implemented in <code>ExtendedKalmanFilter.hxx</code> and <code>ExtendedKalmanFilter.cxx</code>. The class \link Verdandi::ExtendedKalmanFilter ExtendedKalmanFilter\endlink is a template class: <code>ExtendedKalmanFilter<T, ClassModel, ClassObservationManager></code>. <code>T</code> is the type of the elements to be stored (e.g. <code>double</code>), <code>ClassModel</code> is the type of the model (e.g. <code>ClampedBar<double></code>), <code>ClassObservationManager</code> is the type of the observation manager (e.g. <code>LinearObservationManager<double></code>).

Here is how you may use the \link Verdandi::ExtendedKalmanFilter ExtendedKalmanFilter\endlink class:

\precode
ExtendedKalmanFilter<real, ClampedBar<real>,
        LinearObservationManager<real> > driver(argv[1]); [1]

driver.Initialize(argv[1]); [2]

while (!driver.HasFinished()) [6]
{
    driver.InitializeStep(); [3]

    driver.Forward(); [4]

    driver.Analyze(); [5]
}
\endprecode

\comment
  <li> First build the \link Verdandi::ExtendedKalmanFilter ExtendedKalmanFilter\endlink driver and read option keys in the configuration file with the construction \link Verdandi::ExtendedKalmanFilter::ExtendedKalmanFilter(string c_f) ExtendedKalmanFilter(configuration_file)\endlink. </li>

  <li> Then initialize the driver, the model and the observation manager with \link Verdandi::ExtendedKalmanFilter::Initialize(string configuration_file) Initialize(configuration_file)\endlink. This optionally computes an analysis (BLUE) with the model initial condition. </li>

  <li> Optionally intialize a step with \link Verdandi::ExtendedKalmanFilter::InitializeStep() InitializeStep()\endlink. This initializes a step for the model. </li>

  <li> Perform a step forward and propagate the state error variance with \link Verdandi::ExtendedKalmanFilter::Forward() Forward()\endlink. </li>

  <li> Compute the analysis with \link Verdandi::ExtendedKalmanFilter::Analyze() Analyze()\endlink, whenever observations are available. </li>

  <li> Compute the data assimilation until the model has finished: \link Verdandi::ExtendedKalmanFilter::HasFinished() HasFinished()\endlink returns true if the simulation is done, false otherwise. </li>
\endcomment


\section algorithm2 Extended Kalman filter algorithm

<ol>
        <li>Predict: 
            - \f$x_h^f = \mathcal{M}_{h-1}(x_{h-1}^a)\f$,<br>
            - \f$P_h^f = M_{h-1} P_{h-1}^a M_{h-1}^T \f$,</li>
        <li>Update: 
            - \f$K_h = P_h^fH_h^{T}(H_hP_h^fH_h^{T} + R_h)^{-1}\f$, <br>
            - \f$x_h^a = x_h^f + K_h(y_h - \mathcal{H}_h(x_h^f))\f$,<br>
            - \f$P_h^a = (I - K_hH_h)P_h^f\f$.</li>
</ol>
With: <br>
\f$x_h^f\f$ forecast state vector; <br>
\f$x_h^a\f$ analysis state vector; <br>
\f$y_h\f$ observation vector; <br>
\f$\mathcal{H}_h\f$ observation operator that maps the state space to the observation space; <br>
\f$H_h\f$ observation operator linearized at \f$x^f_h\f$; <br>
\f$P^f_h\f$ error covariance matrix of \f$x_h^f\f$; <br>
\f$P^a_h\f$ error covariance matrix of \f$x_h^a\f$; <br>
\f$R_h\f$ observational error covariance matrix; <br>
\f$K_h\f$ analysis gain matrix; <br>
\f$\mathcal{M}_h\f$ model; <br>
\f$M_h\f$ model linearized at \f$x^f_h\f$.

*/
